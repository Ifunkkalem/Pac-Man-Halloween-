<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Man Halloween Labyrinth</title>
    <!-- Tailwind CSS untuk styling dan responsiveness -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons untuk tombol arah -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Ethers.js library for Web3 interaction -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900;800;300&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background: radial-gradient(circle at top, #2b0033, #0a0010); /* Match Menu Background */
            color: white;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        #game-container {
            max-width: 800px; 
            width: 100%;
            margin-bottom: 1rem;
            border: 4px solid #ff8c00; /* Oranye neon */
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(128, 0, 128, 0.7); /* Ungu neon */
        }
        canvas {
            display: block;
            background-color: #000000;
            width: 100%; 
            height: auto;
            aspect-ratio: 4 / 3; 
        }
        .control-grid {
            grid-template-areas:
                ". up ."
                "left center right"
                ". down .";
            width: 200px; 
            margin-top: 1rem;
        }
        .control-btn {
            background-color: #FF6600; 
            color: #1a1a2e;
            border-radius: 9999px; 
            padding: 1rem;
            box-shadow: 0 4px 0 #D35400;
            transition: all 0.1s;
            cursor: pointer;
            margin: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .control-btn:active {
            box-shadow: 0 0 0 #D35400;
            transform: translateY(4px);
        }
        #messageModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }
        #modalContent {
             animation: neon-glow 1.5s infinite alternate;
        }
        
        @keyframes neon-glow {
            from { box-shadow: 0 0 5px #ff8c00, 0 0 10px #800080; }
            to { box-shadow: 0 0 10px #ff8c00, 0 0 20px #800080; }
        }
    </style>
</head>
<body class="min-h-screen">

    <!-- Modal untuk Pesan Status/Game Over -->
    <div id="messageModal">
        <div id="modalContent" class="flex flex-col p-8 rounded-xl bg-gray-900 border-4 border-yellow-500 shadow-2xl w-11/12 max-w-sm">
            <h2 id="modalTitle" class="text-3xl font-extrabold mb-4 text-center text-yellow-400"></h2>
            <p id="modalMessage" class="text-lg text-center mb-6"></p>
            <button onclick="hideMessage();" class="px-4 py-2 bg-purple-600 hover:bg-purple-700 rounded-lg font-bold transition duration-150">
                Tutup
            </button>
        </div>
    </div>

    <header class="w-full max-w-xl flex justify-between items-center p-4 bg-gray-800 rounded-lg mb-4 shadow-lg">
        <h1 class="text-xl font-bold flex items-center text-purple-400">
            <span class="text-3xl mr-2 text-yellow-500">ðŸŽƒ</span> Labyrinth
        </h1>
        <div class="text-lg">Score: <span id="score" class="font-extrabold text-yellow-400">0</span></div>
    </header>

    <div id="game-container">
        <canvas id="game" width="800" height="600"></canvas>
    </div>

    <!-- Kontrol Mobile -->
    <div class="control-grid grid grid-cols-3 gap-2">
        <button id="up-btn" class="control-btn" style="grid-area: up;" ontouchstart="setDirection(2)" ontouchend="stopDirection()" onmousedown="setDirection(2)" onmouseup="stopDirection()">
            <i data-lucide="arrow-up" class="w-6 h-6"></i>
        </button>
        <button id="left-btn" class="control-btn" style="grid-area: left;" ontouchstart="setDirection(1)" ontouchend="stopDirection()" onmousedown="setDirection(1)" onmouseup="stopDirection()">
            <i data-lucide="arrow-left" class="w-6 h-6"></i>
        </button>
        <div style="grid-area: center;"></div> 
        <button id="right-btn" class="control-btn" style="grid-area: right;" ontouchstart="setDirection(0)" ontouchend="stopDirection()" onmousedown="setDirection(0)" onmouseup="stopDirection()">
            <i data-lucide="arrow-right" class="w-6 h-6"></i>
        </button>
        <button id="down-btn" class="control-btn" style="grid-area: down;" ontouchstart="setDirection(3)" ontouchend="stopDirection()" onmousedown="setDirection(3)" onmouseup="stopDirection()">
            <i data-lucide="arrow-down" class="w-6 h-6"></i>
        </button>
    </div>

    <!-- Tombol Web3 & Navigasi -->
    <div class="flex flex-wrap justify-center gap-4 mt-8 w-full max-w-md">
        <button id="startOnchainBtn" onclick="requestStartGameTransaction()" class="px-6 py-3 bg-green-600 hover:bg-green-700 text-white font-bold rounded-lg shadow-xl transition duration-150">
            START GAME (Bayar 0.01 SOMI)
        </button>
        <button onclick="window.location.href='index.html'" class="px-6 py-3 bg-red-600 hover:bg-red-700 text-white font-bold rounded-lg shadow-xl transition duration-150">
            BACK TO MENU
        </button>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, setLogLevel, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        setLogLevel('Debug');

        // ====================================================================
        // --- FIREBASE & AUTHENTICATION SETUP (Untuk Score Submission) ---
        // ====================================================================
        
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        const EMPTY_CONFIG_FALLBACK = '{"apiKey":"AIzaSyB-fallback","authDomain":"projectId.firebaseapp.com","projectId":"fallback-project","storageBucket":"projectId.appspot.com","messagingSenderId":"123456789012","appId":"1:123456789012:web:abac123456789012"}';
        
        function getFirebaseConfig() {
            const rawConfig = typeof __firebase_config !== 'undefined' ? __firebase_config : null;
            let config = null;
            if (rawConfig && typeof rawConfig === 'string' && rawConfig.trim() !== '') {
                try { config = JSON.parse(rawConfig); } catch (e) { console.error("Gagal parse Config sistem.", e); }
            }
            if (!config || Object.keys(config).length === 0) {
                 try { config = JSON.parse(EMPTY_CONFIG_FALLBACK); } catch (e) { return null; }
            }
            return config;
        }

        let db = null;
        let auth = null;
        let userId = null;
        let firebaseReady = false;
        let displayName = "Player"; // Default display name

        async function initializeFirebaseAndAuth() {
            const firebaseConfig = getFirebaseConfig();
            if (!firebaseConfig) { console.error("Firebase GAGAL: Config tidak tersedia."); return; }
            
            try {
                const app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                
                if (initialAuthToken) { await signInWithCustomToken(auth, initialAuthToken); } else { await signInAnonymously(auth); }

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        firebaseReady = true;
                        await loadDisplayName();
                        console.log("Firebase Siap untuk Leaderboard.");
                    } else {
                        userId = null;
                        firebaseReady = false;
                        console.warn("Firebase Gagal Otentikasi.");
                    }
                });

            } catch (error) {
                console.error("Error Firebase Init/Auth:", error);
                firebaseReady = false;
            }
        }
        
        async function loadDisplayName() {
            if (!db || !userId) return;
            // Mengambil DisplayName dari profil pribadi user
            const docRef = doc(db, 'artifacts', appId, 'users', userId, 'config', 'profile');
            try {
                const docSnap = await getDoc(docRef);
                if (docSnap.exists() && docSnap.data().displayName) {
                    displayName = docSnap.data().displayName;
                }
            } catch (e) {
                console.warn("Could not load display name, using default 'Player'.", e);
            }
        }
        
        async function submitFinalScore(score) {
            if (!firebaseReady || !userId || !db) {
                console.warn("Skor tidak disimpan: Firebase tidak siap.");
                return;
            }
            
            const scoreData = {
                score: score,
                userId: userId,
                displayName: displayName, 
                timestamp: Date.now(),
                app: appId 
            };
            
            try {
                // Menyimpan di Public Data Collection untuk Leaderboard
                // Path: /artifacts/{appId}/public/data/leaderboard/{documentId}
                const path = collection(db, 'artifacts', appId, 'public', 'data', 'leaderboard');
                // Menggunakan setDoc(doc(path)) untuk membuat ID unik otomatis
                await setDoc(doc(path), scoreData); 
                console.log(`Skor ${score} berhasil dikirim ke Leaderboard Internal.`);
            } catch (e) {
                console.error("Error saat mengirim skor ke Leaderboard Internal: ", e);
            }
        }
        
        initializeFirebaseAndAuth();

        // ====================================================================
        // --- FUNGSI MODAL ---
        // ====================================================================

        const modal = document.getElementById("messageModal");
        window.showMessage = (title, message) => {
            document.getElementById("modalTitle").innerText = title;
            document.getElementById("modalMessage").innerText = message;
            modal.style.display = 'flex';
        }

        window.hideMessage = () => {
            modal.style.display = 'none';
        }

        // ====================================================================
        // --- WEB3 TRANSACTION LOGIC (DI SINI) ---
        // ====================================================================

        const SOMNIA_RECEIVER_ADDRESS = "0x89798C0B7e9B2a7f0A812a32c324269e88C359D4"; // Ganti jika perlu
        const SOMNIA_TX_AMOUNT = "0.01"; 
        const startGameButton = document.getElementById("startOnchainBtn");

        async function realSomniaTx(amountInEth) {
            if (typeof window.ethers === 'undefined' || !window.ethereum) {
                showMessage("Web3 Error", "Web3 (MetaMask/Ethers) tidak terdeteksi. Pastikan dompet terinstal dan terhubung.");
                return { success: false, message: "Web3 provider not found." };
            }
            
            try {
                await window.ethereum.request({ method: 'eth_requestAccounts' });

                const provider = new window.ethers.BrowserProvider(window.ethereum);
                const signer = await provider.getSigner();
                const amountWei = window.ethers.parseEther(amountInEth);

                const tx = {
                    to: SOMNIA_RECEIVER_ADDRESS,
                    value: amountWei,
                };

                const txResponse = await signer.sendTransaction(tx);
                showMessage("Transaksi Dikirim", `Transaksi berhasil dikirim. Hash: ${txResponse.hash}. Menunggu konfirmasi...`);
                
                const txReceipt = await txResponse.wait();

                if (txReceipt && txReceipt.status === 1) {
                    return { success: true, message: `Transaksi berhasil dikonfirmasi.` };
                } else {
                    return { success: false, message: "Transaksi gagal dikonfirmasi (Status 0)." };
                }
            } catch (error) {
                console.error("Error saat transaksi on-chain:", error);
                let message = "Transaksi dibatalkan oleh pengguna atau terjadi kesalahan jaringan.";
                if (error.code === 4001) { message = "Transaksi dibatalkan oleh pengguna."; }
                
                return { success: false, message: message };
            }
        }

        window.requestStartGameTransaction = async () => {
            if (running) return;

            startGameButton.disabled = true;
            startGameButton.innerText = "Memproses Transaksi...";
            
            showMessage("Meminta Transaksi", `Meminta konfirmasi di dompet Anda untuk transfer ${SOMNIA_TX_AMOUNT} SOMI. Harap perhatikan notifikasi dompet Anda!`);
            
            const txResult = await realSomniaTx(SOMNIA_TX_AMOUNT);

            if (txResult.success) {
                startGameLoop();
                showMessage("Transaksi Berhasil âœ…", `${txResult.message} Game dimulai!`);
            } else {
                showMessage("Transaksi Gagal âŒ", txResult.message);
                startGameButton.disabled = false;
                startGameButton.innerText = "START GAME (Bayar 0.01 SOMI)";
            }
        }
        
        // ====================================================================
        // --- LOGIKA GAME PAC-MAN CORE ---
        // ====================================================================

        lucide.createIcons();

        let running = false;
        let currentScore = 0; 
        const PLAYER_SPEED = 3.5; 
        const GHOST_SIZE = 20; 
        const PLAYER_SIZE = 25; 
        const CANDY_VALUE = 10; 
        
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d");
        const scoreEl = document.getElementById("score");

        let x = 400; let y = 320; let vx = 0; let vy = 0; let currentDirection = 0; 
        
        // Fungsi Kontrol Mobile
        window.setDirection = (direction) => {
            if (!running) return;
            currentDirection = direction;
            vx = 0; vy = 0;
            if (direction === 0) { vx = PLAYER_SPEED; } 
            else if (direction === 1) { vx = -PLAYER_SPEED; } 
            else if (direction === 2) { vy = -PLAYER_SPEED; } 
            else if (direction === 3) { vy = PLAYER_SPEED; } 
        }

        window.stopDirection = () => {
            vx = 0;
            vy = 0;
        }

        // Definisi Dinding
        const WALL_THICKNESS = 20;
        const walls = [
            { x: 0, y: 0, width: 800, height: WALL_THICKNESS }, { x: 0, y: 580, width: 800, height: WALL_THICKNESS }, 
            { x: 0, y: 0, width: WALL_THICKNESS, height: 600 }, { x: 780, y: 0, width: WALL_THICKNESS, height: 600 }, 
            { x: 300, y: 280, width: 200, height: WALL_THICKNESS }, 
            { x: 100, y: 100, width: 200, height: WALL_THICKNESS }, { x: 100, y: 100, width: WALL_THICKNESS, height: 100 },
            { x: 100, y: 480, width: 200, height: WALL_THICKNESS }, { x: 100, y: 400, width: WALL_THICKNESS, height: 100 },
            { x: 500, y: 100, width: 200, height: WALL_THICKNESS }, { x: 680, y: 100, width: WALL_THICKNESS, height: 100 },
            { x: 500, y: 480, width: 200, height: WALL_THICKNESS }, { x: 680, y: 400, width: WALL_THICKNESS, height: 100 },
            { x: 380, y: 100, width: 40, height: WALL_THICKNESS }, { x: 390, y: 120, width: WALL_THICKNESS, height: 80 },
            { x: 380, y: 480, width: 40, height: WALL_THICKNESS }, { x: 390, y: 400, width: WALL_THICKNESS, height: 80 },
            { x: 200, y: 200, width: WALL_THICKNESS, height: 80 }, { x: 220, y: 260, width: 80, height: WALL_THICKNESS },
            { x: 580, y: 200, width: WALL_THICKNESS, height: 80 }, { x: 500, y: 260, width: 80, height: WALL_THICKNESS },
            { x: 200, y: 400, width: WALL_THICKNESS, height: 80 }, { x: 220, y: 400, width: 80, height: WALL_THICKNESS },
            { x: 580, y: 400, width: WALL_THICKNESS, height: 80 }, { x: 500, y: 400, width: 80, height: WALL_THICKNESS },
        ];

        function drawWalls() {
            ctx.fillStyle = "rgba(0, 100, 255, 0.8)"; 
            for (const wall of walls) { ctx.fillRect(wall.x, wall.y, wall.width, wall.height); }
        }

        function checkAABBCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width && rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height && rect1.y + rect2.height > rect2.y;
        }

        function checkPlayerWallCollision(newX, newY) {
            const playerRect = { x: newX - PLAYER_SIZE, y: newY - PLAYER_SIZE, width: 2 * PLAYER_SIZE, height: 2 * PLAYER_SIZE };
            for (const wall of walls) {
                if (checkAABBCollision(playerRect, wall)) { return true; }
            }
            return false; 
        }

        let ghosts = [];
        class Ghost {
            constructor(x, y, color, behavior, speed) {
                this.x = x; this.y = y; this.color = color; this.behavior = behavior; this.speed = speed;
                this.radius = GHOST_SIZE; this.randomMoveCooldown = 0; this.vx = 0; this.vy = 0;
            }
        }
        
        function moveGhost(ghost) {
            let targetX = x, targetY = y;
            let dx = 0, dy = 0;

            if (ghost.behavior === "chase" || ghost.behavior === "flee") {
                dx = targetX - ghost.x; dy = targetY - ghost.y;
                if (ghost.behavior === "flee") { dx *= -1; dy *= -1; }
                const distance = Math.sqrt(dx * dx + dy * dy);
                if (distance > 0) {
                    ghost.vx = (dx / distance) * ghost.speed;
                    ghost.vy = (dy / distance) * ghost.speed;
                }
            } else if (ghost.behavior === "random") {
                ghost.randomMoveCooldown--;
                if (ghost.randomMoveCooldown <= 0) {
                    ghost.vx = (Math.random() - 0.5) * ghost.speed * 2;
                    ghost.vy = (Math.random() - 0.5) * ghost.speed * 2;
                    ghost.randomMoveCooldown = 60; 
                }
            }
            
            const newX = ghost.x + ghost.vx;
            const newY = ghost.y + ghost.vy;
            const ghostRect = { x: newX - ghost.radius, y: newY - ghost.radius, width: 2 * ghost.radius, height: 2 * ghost.radius };
            
            let collided = false;
            for (const wall of walls) {
                if (checkAABBCollision(ghostRect, wall)) {
                    collided = true;
                    if (ghost.vx !== 0) ghost.vx *= -1;
                    if (ghost.vy !== 0) ghost.vy *= -1;
                    if (ghost.behavior === "random") { ghost.randomMoveCooldown = 0; }
                    break;
                }
            }

            if (!collided) {
                ghost.x = newX;
                ghost.y = newY;
            }
        }

        function drawGhost(ghost) {
            const r = ghost.radius;
            ctx.fillStyle = ghost.color;
            ctx.beginPath();
            ctx.arc(ghost.x, ghost.y - r / 2, r, Math.PI, 0, false);
            ctx.lineTo(ghost.x + r, ghost.y + r);
            ctx.lineTo(ghost.x + r * 0.75, ghost.y + r - 5);
            ctx.lineTo(ghost.x + r * 0.5, ghost.y + r);
            ctx.lineTo(ghost.x - r, ghost.y + r);
            ctx.closePath();
            ctx.fill();

            // Eyes
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.arc(ghost.x - r / 2, ghost.y - r / 2, 4, 0, 2 * Math.PI);
            ctx.arc(ghost.x + r / 2, ghost.y - r / 2, 4, 0, 2 * Math.PI);
            ctx.fill();
        }

        function checkCollision(ghost) {
            const distance = Math.sqrt(Math.pow(x - ghost.x, 2) + Math.pow(y - ghost.y, 2));
            return distance < PLAYER_SIZE + ghost.radius; 
        }
        
        let candy = [];
        function setupCandy() {
            candy = [];
            const rows = 15; const cols = 20; 
            const paddingX = 40; const paddingY = 40;
            const spacingX = (canvas.width - 2 * paddingX) / (cols - 1);
            const spacingY = (canvas.height - 2 * paddingY) / (rows - 1);
            const candyRectSize = 10; 

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const candyX = paddingX + c * spacingX;
                    const candyY = paddingY + r * spacingY;
                    
                    if (Math.abs(candyX - 400) < 60 && Math.abs(candyY - 300) < 60) continue; 
                    
                    let isInsideWall = false;
                    const candyRect = {
                        x: candyX - candyRectSize / 2, y: candyY - candyRectSize / 2, 
                        width: candyRectSize, height: candyRectSize
                    };

                    for (const wall of walls) {
                        const collisionMargin = 5; 
                        const wallCheck = {
                            x: wall.x - collisionMargin, y: wall.y - collisionMargin,
                            width: wall.width + 2 * collisionMargin, height: wall.height + 2 * collisionMargin
                        };
                        
                        if (checkAABBCollision(candyRect, wallCheck)) {
                            isInsideWall = true;
                            break;
                        }
                    }

                    if (!isInsideWall) {
                        candy.push({ x: candyX, y: candyY });
                    }
                }
            }
        }

        function drawCandy() {
            ctx.fillStyle = "orange";
            for (const item of candy) {
                const radius = 6;
                ctx.beginPath();
                ctx.arc(item.x, item.y, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillStyle = "green"; 
                ctx.fillRect(item.x - 1, item.y - radius - 3, 2, 3);
            }
        }

        function checkCandyCollection() {
            for (let i = candy.length - 1; i >= 0; i--) {
                const item = candy[i];
                const distance = Math.sqrt(Math.pow(x - item.x, 2) + Math.pow(y - item.y, 2));

                if (distance < PLAYER_SIZE) {
                    currentScore += CANDY_VALUE;
                    candy.splice(i, 1); 

                    if (candy.length === 0) {
                        endGame(true); 
                        return true;
                    }
                }
            }
            return false;
        }

        /** Menggambar Pacman. */
        function drawPacman() {
            const radius = PLAYER_SIZE;
            let startAngle = 0;
            let endAngle = 2 * Math.PI;

            const mouthOpenness = Math.sin(Date.now() / 100) * 0.2 + 0.5;
            const mouthAngle = mouthOpenness * Math.PI / 4;

            switch (currentDirection) {
                case 0: startAngle = mouthAngle; endAngle = 2 * Math.PI - mouthAngle; break; 
                case 1: startAngle = Math.PI + mouthAngle; endAngle = 3 * Math.PI - mouthAngle; break; 
                case 2: startAngle = 1.5 * Math.PI + mouthAngle; endAngle = 3.5 * Math.PI - mouthAngle; break; 
                case 3: startAngle = 0.5 * Math.PI + mouthAngle; endAngle = 2.5 * Math.PI - mouthAngle; break; 
            }
            
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.arc(x, y, radius, startAngle, endAngle);
            ctx.lineTo(x, y);
            ctx.closePath();
            ctx.fill();
        }

        /** Game Loop Utama */
        function loop() {
            requestAnimationFrame(loop);

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!running) {
                ctx.fillStyle = "white";
                ctx.textAlign = "center";
                ctx.font = "30px 'Inter', sans-serif";
                ctx.fillText("Klik START untuk Bermain!", canvas.width / 2, canvas.height / 2);
                return;
            }
            
            drawWalls();

            const newX = x + vx;
            const newY = y + vy;

            if (!checkPlayerWallCollision(newX, y)) { x = newX; } else { vx = 0; }
            if (!checkPlayerWallCollision(x, newY)) { y = newY; } else { vy = 0; }

            const minBound = WALL_THICKNESS + PLAYER_SIZE;
            const maxBoundX = canvas.width - WALL_THICKNESS - PLAYER_SIZE;
            const maxBoundY = canvas.height - WALL_THICKNESS - PLAYER_SIZE;

            if (x < minBound) x = minBound;
            if (x > maxBoundX) x = maxBoundX;
            if (y < minBound) y = minBound;
            if (y > maxBoundY) y = maxBoundY;
            
            drawPacman();
            drawCandy();
            checkCandyCollection();
            
            for (const ghost of ghosts) {
                moveGhost(ghost);
                drawGhost(ghost);

                if (checkCollision(ghost)) {
                    endGame(false); 
                    return; 
                }
            }
            
            scoreEl.innerText = currentScore;
        }
        
        /** Memulai Game Loop */
        function startGameLoop() {
            running = true;
            currentScore = 0;
            
            ghosts = [
                new Ghost(50, 50, "#FF0000", "chase", 2.0), new Ghost(750, 50, "#00FFFF", "random", 2.0),    
                new Ghost(750, 550, "#FF69B4", "flee", 1.5)       
            ];
            
            setupCandy();
            x = 400; y = 320; vx = 0; vy = 0; currentDirection = 0;
            
            scoreEl.innerText = currentScore; 
            startGameButton.innerText = "GAME RUNNING...";
            startGameButton.disabled = true;
        }

        /** Dipanggil ketika game over/win. */
        function endGame(isWin) {
            if (!running) return;
            running = false;
            
            const title = isWin ? "SELAMAT! ðŸ†" : "GAME OVER!";
            const message = isWin 
                ? `Anda memenangkan permainan! Skor Akhir: ${currentScore}`
                : `Anda tertangkap hantu. Skor Akhir: ${currentScore}. Coba lagi!`;
            
            showMessage(title, message);
            
            if (currentScore > 0) {
                submitFinalScore(currentScore); 
            }
            
            startGameButton.disabled = false;
            startGameButton.innerText = "START GAME (Bayar 0.01 SOMI)";
        }

        window.onload = loop; 
    </script>
</body>
</html>
